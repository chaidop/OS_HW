Polykarpou Christoforos, 2668, chpolykarpou@uth.gr
Tsaggaris Andreas, 2667, antsangaris@uth.gr
Poulianou Chaido, 2613, cpoulianou@uth.gr

Το αρχείο ελέγχου επιπέδου χρήστη ονομάζεται slob_test.
Δημιουργήσαμε 2 system calls για δέσμευση και αποδέσμευση μνήμης, slob_kmalloc και slob_kfree.
Επίσης, 2 system calls για την επιστροφή των δεσμευμένων bytes και του ολικού ελεύθερου χώρου
σε όλες τις λίστες, slob_get_total_alloc_mem και slob_get_total_free_mem.
Επίσης εισάγαμε 2 static μεταβλητές για να κρατάνε αυτές τις τιμές και 2 συναρτησεις που 
τις επιστρέφουν, τις οποίες ορίζουμε στο slab.h για να μπορούν να καλούν τα system calls.
Οι βιβλιοθηκη επιπέδου χρήστη για τα πρώτα 2 system calls είναι η slob_mem_wrapper
και για τα αλλα 2 η slob_wrapper
Μεταγλώττισή τους γίνεται με την εντολή:
gcc -c slob_wrapper.c -o slob_wrapper.o
και η δημιουργια της δυναμικης βιβλιοθήκης:
sudo ar rcs libslo_wrapper.a slob_wrapper.o
(αντίστοιχα για την slob_mem_wrapper)
Η μεταγλώττιση του αρχείου εφαρμογής χρήστη:
gcc -c slob_test.c -o slob_test.o
και σύνδεσή της με τις βιβλιοθήκες:
gcc -o slob_test slob_test.o -L. -lslob_mem_wrapper -lslob_wrapper
Η εκτέλεση του γίνεται με:
./slob_test
Για να φανεί και η διαδικασία δέσμευσης, εκτέλεση της εντολής:
dmesg

=================================== ΠΑΡΑΤΗΡΗΣΕΙΣ ===============================

Γενικά τρέχοντας το slob_test.c και με χρήση του kernel για τον κάθε αλγόριθμο, παρατηρήσαμε τα εξής:

- Ο Best-Fit αποδείχθηκε πιο αργός κάθε άλλον από τους 2 αλγορίθμους. Αυτό συμβαίνει γιατί τρέχει 
τη λίστα των μπλοκ του best page 2 φορές (1 για έλεγχο ύπαρξης μπλοκ με τη βοηθητική συνάρτηση slob_page_best_fit_check 
και 1 για να το ξαναβρεί στην slob_page_alloc) και 1 loop σε όλες τις σελίδες για να βρει το best page μέχρι τέλος,
ενώ ο SLOB με First-Fit και Next-Fit σταματάνε με το πρώτο επαρκές σε χώρο μπλοκ και σελίδα, οπότε δεν τρέχουν 
όλη τη λίστα μέχρι τέλους. Αυτό τους καθιστά και πιο γρήγορους από τον Best-Fit. 
Το πρόβλημα ταχύτητας του Best-Fit φαίνεται ακόμα και με την εκκίνηση του kernel, καθώς κρατάει μερικά λεπτά
παραπάνω να ξεκινήσει το σύστημα από ότι θα έπαιρνε χωρίς Best-Fit.

-Παρατηρώντας την επιλογή δέσμευσης μπλοκ του Best-Fit από το dmesg, βλέπουμε ότι υπάρχουν συγκριτικά με τους άλλους
αλγορίθμους πολύ λιγότερες περιπτώσεις που δε βρίσκει το κατάλληλο μπλοκ (τυπώνεται NONE) και δεσμέυει νέο page. 
Αντιθέτως χωρίς Best-Fit, δεν έχουμε τόσο καλή διαχείρηση της μνήμης, ώστε κάθε request να μη βρίσκει το
καλύερο μπλοκ, αλλά να επιλέγεται ένα με πολύ παραπάνω μνήμη από όση χρειάζεται. Αυτό έχει ως αποτέλεσμα
κάποιο επόμενο πιθανό request που ητάει μπλοκ με περισσότερη μνήμη να έχει εξαντληθεί και να χρειαστεί 
ψάξιμο ή και δέσμευση νέας σελίδας (χειρότερη περίπτωση). Αυτός ο τρόπος δέσμευσης μπλοκ δημιουργεί πολλά
'κενά μνήμης' σε κάθε σελίδα, δηλαδη μεγάλο πρόβλημα εσωτερικού κατακερματισμού, καθώς δίνει πολύ μεγαλύτερη 
μνήμη σε requests από όση πραγματικά χρειάζονται, με αποτέλεσμα τη δέσμευση επιπλέον μνήμης για τα επόμενα 
requests που δε 'χωράνε' στα εναπομείναντα μπλοκ.
Αυτό φαίνεται και από τα αποτέλεσματα τρεξίματος του slob_test.c, όπου ο αριθμός bytes που δεσμεύονται χωρίς 
Best-Fit είναι πολύ μεγαλύτερος από ότι με Best-Fit.

- Ο Best-Fit έχει μεγαλύτερο ελεύθερο χώρο συνολικά σε όλες τις λίστες των σελίδων από ότι χωρίς Best-Fit, όπως
φαίνεται από το τρέξιμο του slob_test. Αυτό γίνεται γιατί ψάχνει πάντα για το καλύτερο δυνατό μπλοκ με τη
μικρότερη δυνατή μνήμη, οπότε λογικά αφήνει και περισσότερο ελεύθερο χώρο.

- Ο Best-Fit λόγω το ότι ψάχνει πάντα το καλύτερο μπλοκ, μπορεί σε συνεχόμενες περιοχές μνήμης αυτό το best block
να είναι αρκετά μακριά σε σχέση με του προηγούμενου επιλεγμένου μπλοκ. Τα δεδομένα έχουν δηλαδή μεγάλο κενό μνήμης
μεταξύ τους, άρα είναι μεγαλύτερο το πρόβλημα του εξωτερικού κατακερματισμού με τον Best-Fit, ακόμα και αν τα δεδομένα
χωράνε σχεδό τέλεια σε κάθε επιλεγμένο μπλοκ( χαμηλός εσωτερικός κατακερματισμός).

Συνοπτικά, ο Best-Fit αποτελεί μια πολύ καλή λύση για τον εσωτερικό κατακερματισμό καθώς διαχειρίζεται καλύτερα τη δέσμευση.
Ωστόσο, ο τρόπος λειτουργίας του, δηλαδή το ότι ψάχνει για το καλύτερο block σε όλη τη λίστα μέχρι τέλους,
τον καθιστά πολύ αργό για εκμετάλευση και δημιουργεί πρόβλημα εξωτερικού κατακερματισμού. Οπότε δεν είναι εντελώς συνετή η
χρήση του σε συστήματα που συγκεντρώνονται στην επίδοση, προτιμότερη επιλογή θα ήταν ο First-Fit με Next-Fit.
